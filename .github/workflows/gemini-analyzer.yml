name: Revue de Code Critique (ESLint + Gemini)

on:
  push:
    branches:
      - main
      - master
      - develop
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - master
      - develop
  # Permet de lancer le workflow manuellement depuis l'interface GitHub
  workflow_dispatch:

jobs:
  code_quality_check:
    runs-on: ubuntu-latest
    
    # 1. D√©finition des variables dynamiques (user info)
    # Utilit√© : Ces variables injectent le nom et l'e-mail de l'utilisateur qui a d√©clench√© l'√©v√©nement 
    # (via 'push' ou 'pull_request') dans l'environnement du job.
    env:
      # R√©cup√®re l'e-mail ou le login de l'utilisateur qui a initi√© l'action
      PUSHER_EMAIL: ${{ github.event.pusher.email || github.event.pull_request.user.email }}
      PUSHER_NAME: ${{ github.event.pusher.name || github.event.pull_request.user.login }}
      
      # NOTE: Si vous voulez que le centre d'int√©r√™t (PREF_INTEREST) soit variable en CI/CD, 
      # il doit √™tre d√©fini soit ici (en dur) soit comme un Secret d'Organisation/D√©p√¥t.
      # Sinon, il prendra la valeur par d√©faut 'la qualit√© du code'.
      # Exemple ci-dessous utilisant un Secret d'environnement appel√© CI_PREF_INTEREST (√† d√©finir)
      PREF_INTEREST: ${{ secrets.CI_PREF_INTEREST || 'la performance et la s√©curit√©' }}

    steps:
      - name: ‚¨áÔ∏è Checkout du code
        uses: actions/checkout@v4
        # Utilit√© : T√©l√©charge le code du d√©p√¥t sur la machine virtuelle de GitHub.

      - name: üõ†Ô∏è Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
        # Utilit√© : Configure l'environnement Python n√©cessaire.

      - name: üì• Installation des d√©pendances (Python)
        run: pip install -r requirements.txt
        # Utilit√© : Installe les biblioth√®ques Python n√©cessaires (google-genai, python-dotenv, tqdm, etc.).

      - name: üì¶ Installation des d√©pendances (Node/ESLint)
        id: npm_install
        # Utilit√© : Ex√©cute npm install UNIQUEMENT si package.json existe.
        run: |
          if [ -f package.json ]; then
            npm install
          else
            echo "::notice file=package.json::Fichier package.json non trouv√©. Saut de l'installation Node/ESLint."
          fi

      - name: üî¨ Ex√©cution de l'Analyse Statique (ESLint)
        # Utilit√© : Ex√©cute ESLint UNIQUEMENT si l'installation pr√©c√©dente a r√©ussi (i.e. package.json existait).
        # Nous ajoutons une condition pour sauter l'√©tape si npm install n'a pas √©t√© fait.
        if: success() && steps.npm_install.outcome != 'skipped'
        run: |
          ./node_modules/.bin/eslint . --ext .js,.jsx,.ts,.tsx --max-warnings 0
        continue-on-error: false

      - name: üß† Ex√©cution de l'Analyse Critique par Gemini
        run: python gemini_code_analyzer.py
        env:
          # Les variables 'PUSHER_EMAIL', 'PUSHER_NAME' et 'PREF_INTEREST' sont d√©j√† inject√©es au niveau du Job.
          # SECRET CRITIQUE (Cl√© API)
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          # SECRETS SMTP (pour l'envoi d'e-mail)
          SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SENDER_EMAIL: ${{ secrets.SENDER_EMAIL }}
        # Utilit√© : Lance le script d'analyse, qui applique la d√©tection de langage, les r√®gles dynamiques
        # (typage Python, etc.) et envoie l'e-mail motivant en cas de blocage critique.